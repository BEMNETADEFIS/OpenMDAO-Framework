
--------------------------------
The OpenMDAO Development Process
--------------------------------

.. contents:: Contents

.. sectnum::



Introduction
------------

This is the beginning of the documentation for OpenMDAO developers that
attempts to explain the process of how OpenMDAO development works, and
how to interact with the various tools we use for configuration management,
testing, deployment, etc.  Right now, this is only a very basic outline
that needs to be greatly improved before it is ready for production use,
so if you're reading this now, consider yourself an alpha tester of the
process.  When you come across something that doesn't work or is confusing,
or you have thought of a way to improve some aspect of the process, please
write it down and email it to Bret.A.Naylor@nasa.gov or edit the file
yourself. The source file for this tutorial can be found in
``???`` in the top level directory of your OpenMDAO source 
branch. If you don't know what a branch is, that will be explained below.


Getting Started
---------------

Before you can start working on source code or running tests, you need to get
your own copy of the source code and create an environment that contains all 
of the python modules you need.  To accomplish these things, you'll be using
two tools: `bazaar <http://bazaar-vcs.org>`_ to configuration manage your
source code, and  `zc.buildout <http://pypi.python.org/pypi/zc.buildout>`_ to
keep track  of all  of the python packages that your code depends on.  A python
script called ``mkbranch.py``  has been written to help cut down on the number
of manual steps required before you can start working on your branch.  For a
gentle video introduction to zc.buildout, check out
http://rhodesmill.org/brandon/buildout. Note that on *torpedo* the sound
doesn't work, so it's better to view the buildout video intro from another
machine. 

If you haven't used bazaar before on a particular machine where you intend
to work with bazaar repositories, you should run the ``whoami``
command so that bazaar will know your email address. You need to supply your
first and last name and your email address in the following format:

::

    bzr whoami "Joe Cool <joe@example.com>"

In this way, your contact information will be included whenever you commit
to a repository on that machine.


Where's The Code?
==================

The OpenMDAO project source files are located under ``/OpenMDAO/dev`` on
*torpedo*.  This directory is what is called a shared repository, meaning that
any branches created under it share the same version tree.  Under
``/OpenMDAO/dev`` is a directory called ``trunk``.  This is the *official*
version of the OpenMDAO source. Developers cannot write directly to this
version.  Writing to the trunk can only be done by the configuration manager. 
To make changes to the code, a developer must first create a branch, then make 
and test changes, then make the branch available to the configuration manager 
who will then merge the changes back into the trunk.

The overall directory structure for OpenMDAO looks like this:

``/OpenMDAO``
    The top level directory
    
``/OpenMDAO/dev``
    Shared repository
    
``/OpenMDAO/dev/trunk``
    Release version of the code

``/OpenMDAO/dev/developers/<username>``
    Directory where all active branches for user ``<username>`` are located

``/OpenMDAO/dev/developers/<username>/T<ticket number>-<desc>``
    Top level directory of an active branch for ticket ``<ticket number>``
    with description ``<desc>`` and owned by user ``<username>``
    
``/OpenMDAO/distrib-cache/dist``
    Directory containing python distributions for all packages used in
    OpenMDAO


Layout of a Source Repository
+++++++++++++++++++++++++++++

Within a branch repository itself, located in 
``/OpenMDAO/dev/developers/<username>/T<ticket number>-<desc>``, 
the directory structure will look like this:

``buildout``
    The directory containing the buildout configuration file(s) and all of 
    the content generated by the buildout
    
``docs``
    All Sphinx documentation for the OpenMDAO project
    
``openmdao.main``
    Python package containing all infrastructure source for OpenMDAO
    
``openmdao.lib``
    Python package containing source for the OpenMDAO standard library of plugins
    
``openmdao.recipes``
    Python package containing source for any buildout recipes developed for
    OpenMDAO
    
``openmdao.test``
    Python package containing source for various OpenMDAO plugins used for
    testing
    
``util``
    Miscellaneous scripts and configuration files used by OpenMDAO developers
    
``eggsrc``
    Contains source to be packaged into python eggs that are releasable separately
    from OpenMDAO.  These eggs may or may not depend upon OpenMDAO.  Eggs that have
    not yet been approved to be part of OpenMDAO.lib can live here, as can any eggs
    containing source that is not license compatible with NOSA, for example, GPL.


General Layout of a Namespace Package
+++++++++++++++++++++++++++++++++++++

OpenMDAO is large enough that it makes sense to split it up into multiple python
packages, but we want all of those packages to be under the umbrella of
``openmdao``.
To do this in python, we use what is called a namespace package.  Namespace 
packages all have a similar directory layout.  Currently in OpenMDAO, 
``openmdao.main``, ``openmdao.lib``, ``openmdao.recipes``, and ``openmdao.test``
are all namespace packages that are in the ``openmdao`` namespace.  They all 
have a layout like this:

``openmdao.<package>``
    The top level directory for the package denoted by ``<package>``. This
    contains the ``setup.py`` script which is used to build and 
    create an egg for the package.
    
``openmdao.<package>/docs``
    Documentation specific to the package.
    
``openmdao.<package>/openmdao``
    Contains nothing but a special ``__init__.py`` file and a ``<package>``
    subdirectory.
    
``openmdao.<package>/openmdao/<package>``
    This is where the actual source code, usually a bunch of python files,
    is located.  There could also be a standard python package directory structure
    under this directory as well.
    

Creating a New Package Directory Structure
++++++++++++++++++++++++++++++++++++++++++

The existing OpenMDAO package directory structures were created using a
utility called ``paster`` and a python package called ``ZopeSkel``, which  contains
a number of templates for ``paster``.  To see a list of templates that are
available for ``paster``, type

::

    paster create --list-templates
    
To create a new namespace package, ``cd`` to the directory where you want it to be
located and type:

::

    paster create -t basic_namespace
    
You will be asked a number of questions and then ``paster`` will generate a 
*skeleton* namespace directory structure for you.  After that, you will need to
edit the ``setup.py`` file that is generated by ``paster`` and add whatever source
files are necessary to the ``<namespace>.<package>/<namespace>/<package>``
directory. 

Similarly, to create a new package directory for a regular, non-namespace
package, type

::

    paster create -t basic_package

    

In both cases, ``paster`` will create new files and directories that must be
added to your repository using ``bzr add``.
  
  
Creating Your Branch
====================

A python script, called ``mkbranch.py`` located in the ``util`` directory of
the trunk will help create and configure your development branch for you.  It will
create your branch and create a buildout for you on the branch. Internally, the
script is simply talking to bazaar_ and zc.buildout_. You could perform these
tasks manually, but you should use the script in order to keep your branch
consistent with others in OpenMDAO.  This will make it easier for the
configuration manager to locate and merge your branch, and it will also make it
easier for other developers on the team to help you if you run into a problem.

The following command will create a branch as well as create and bootstrap the
buildout:

::

  <python> /OpenMDAO/dev/trunk/util/mkbranch.py -t <ticket number> [-d <description>][-s <source repository>][-b <config file>][-u <user name>]

where the following parameters are user specified:

``<python>`` 
   The specific version of python you want to use for the
   branch, for example, ``python2.6``.  Whatever version of python you use for
   this command will be *hard-wired* into all of the buildout-generated scripts.

``<ticket number>``
   The ticket number used by the bug tracking system
   
``<description>``
   *(optional)* A short description  of the purpose of the branch. The description
   should be less than 15 characters in length. 
   
``<source repository>``
   *(optional)* The top directory of the repository you want to branch from. If
   not supplied, this defaults to the top directory of the trunk.
   
``<config file>``
   *(optional)* The pathname of a buildout configuration file that will be used
   to run the buildout for the new branch.  This file will be copied into
   ``buildout/buildout.cfg`` in the top level of the new branch.  If not 
   supplied, the buildout.cfg file from the trunk will be used. If that isn't
   what you want, you can easily modify the buildout.cfg file after creating
   the branch and run the buildout again.
   
``<user name>``
   *(optional)* This should be your username on *torpedo*.  This is set 
   automatically for you based on the LOGNAME environment variable, so 
   generally you should not have to set this one.
   

As an example, if I wanted to create a branch off of the trunk to fix a bug in the
unit conversion code based on ticket 321 in the bug tracker and wanted to use
version 2.6 of python, I could issue the following command:

::

   python2.6 /OpenMDAO/dev/trunk/util/mkbranch.py -t 321 -d units_fix 


After the script runs, it places you in the 
``/OpenMDAO/dev/developers/<username>`` directory, where ``<username>`` is your
user name on *torpedo*.  For example, since my user name is *bnaylor*, my branch
from the command above would be created in 
``/OpenMDAO/dev/developers/bnaylor/T321-units_fix``. Branches are named using the
following form:

::

  T<ticket number>-<desc>


where ``<desc>`` is the short description supplied using the ``-d`` argument. 

At this point, your buildout should be configured, and your top level ``buildout``
directory should contain the following subdirectories:

``bin``
    Contains a buildout script, a buildout specific
    python interpreter, and other scripts that depend upon which parts you've
    included as part of your buildout.
    
``develop-eggs``
    Contains links to any directories that you've
    specified in the *develop* list in your ``buildout.cfg`` file.
    
``eggs``
    Contains all of the installed eggs you've listed as dependencies in your
    ``buildout.cfg`` file.
    
``parts``
    Contains any files specific to any parts you've installed as part of your
    buildout. These could be anything. They don't have to be python related.


Working on Your Branch
----------------------

As you make changes to the source code, you may want to modify your buildout
in some way, possibly adding new eggs, updating to new versions, etc. Whenever
this happens, you must re-run the ``buildout`` script that lives in the top
level ``bin`` directory of your buildout.


Editing/Debugging Source Code
=============================

Wing is a very nice integrated editor and debugger for python that is available to
local OpenMDAO developers.  To run it, type ``wing3.1``.

- TODO: create a buildout recipe to customize a wing project file specific to a buildout


Adding New Source Files
=======================

If you create new files or directories that you want to be part of OpenMDAO, you
must add them to your repository by running the command

::

   bzr add <filename>
        
If ``<filename>`` is a directory, all files within the directory will also be
added to the repository, unless they match any of the patterns in the
``.bzrignore``
file located in the top level directory of the branch.  To add a new pattern
for bazaar to ignore, type

::

   bzr ignore <pattern>
   
where ``<pattern>`` can be a filename or a wildcard expression, e.g., ``*.exe``.


If you add a file or directory to the repository by mistake, type

::

   bzr remove <filename> --keep
   
which will remove the file from the repository but will **not** delete it.


            
Testing
-------

By default, your top level ``buildout/bin`` directory will contain a script
called ``test`` that script uses a python package called `nose
<http://somethingaboutorange.com/mrl/projects/nose>`_ to run all of the unit
tests for any package that you specify. For example, to run all of the openmdao
unit tests, do the following:

::

   bin/test openmdao
   
which should generate output something like this:

::

   ..
   ----------------------------------------------------------------------
   Ran 82 tests in 0.888s

   OK

To get a list of options available with ``bin/test``, type ``bin/test --help``
from the ``buildout`` directory.
   
   
Test Coverage
=============

There is a python package called  `coverage
<http://nedbatchelder.com/code/modules/rees-coverage.html>`_ that is accessible
through ``bin/test`` that makes it easy to determine if your tests cover every
line of code in your source files.  To get a coverage report for the openmdao
package, do the following from the ``buildout`` directory:

::

   bin/test openmdao --with-coverage --cover-package=openmdao
   
The report should look something like this:

::

   ................................................................................
   ..
   Name                                Stmts   Exec  Cover   Missing
   -----------------------------------------------------------------
   openmdao                                5      0     0%   2-6
   openmdao.lib                            0      0   100%   
   openmdao.lib.components                 0      0   100%   
   openmdao.lib.drivers                    0      0   100%   
   openmdao.lib.drivers.conmindriver     183    179    97%   149, 233-234, 271
   openmdao.lib.factories                  0      0   100%   
   openmdao.lib.variables                  0      0   100%   
   openmdao.main                           6      3    50%   5-7
   openmdao.main.arrayvar                 48     47    97%   32
   openmdao.main.assembly                103    101    98%   95, 129
   openmdao.main.component                47     41    87%   58, 92, 99, 106, 121, 142
   openmdao.main.constants                 4      4   100%   
   openmdao.main.constraint               44     43    97%   24
   openmdao.main.container               201    185    92%   22-24, 138, 156, 166, 253-254, 276-277, 337, 340, 356, 359, 367-368
   openmdao.main.containervar             50     29    58%   29, 38-43, 49-55, 66-72, 82
   openmdao.main.driver                   18     15    83%   35, 40-41
   openmdao.main.exceptions                5      5   100%   
   openmdao.main.expreval                122    115    94%   27, 32, 36, 40, 85, 177, 222
   openmdao.main.factory                   6      5    83%   25
   openmdao.main.factorymanager           21     16    76%   28, 33-37
   openmdao.main.float                    70     54    77%   38-41, 49-53, 58-61, 69-73, 105, 120
   openmdao.main.hierarchy                49     46    93%   34, 40, 59
   openmdao.main.importfactory            28     25    89%   47-49
   openmdao.main.int                      42     24    57%   31-34, 39-46, 51-54, 59-66
   openmdao.main.interfaces               54     54   100%   
   openmdao.main.logger                    9      9   100%   
   openmdao.main.pkg_res_factory          61     59    96%   88, 114
   openmdao.main.string                   42     28    66%   31-34, 42-46, 51-54, 62-66
   openmdao.main.stringlist               56     40    71%   31-34, 42-46, 51-54, 62-66, 92, 95
   openmdao.main.tarjan                   58     26    44%   52-71, 78-96, 100
   openmdao.main.variable                138    113    81%   22, 54, 65, 73, 101-104, 112, 117, 129, 141, 184, 202, 227, 263, 265-270, 276, 282-285, 289-290
   openmdao.main.vartypemap               19     17    89%   42-45
   openmdao.main.workflow                 56     35    62%   30, 43, 56, 61-75, 79, 86-88, 92
   -----------------------------------------------------------------
   TOTAL                                1545   1318    85%   
   ----------------------------------------------------------------------
   Ran 82 tests in 5.678s

   OK

The numbers in the *Missing* column indicate lines or ranges of lines that are
not covered by the current set of tests.

If you edit source code, the coverage data may become inaccurate, so you should
clear the coverage database by issuing the following command:

::

   bin/test openmdao --cover-erase


Adding New Tests
================

Generally, you should write your tests using python's `unittest
<http://docs.python.org/library/unittest.html>`_ framework if possible,
although the nose_ package is able to discover and run tests that do not use
unittest_.

The following is a simple example of a unit test written using the unittest_
framework.


.. parsed-literal::

    import unittest

    class TestSomeFunctions(unittest.TestCase):

        def setUp(self):
            # put setup code here. It will run at the beginning of each
            # test function (function with name that starts with 'test')

        def tearDown(self):
            # put code here that you want to be run after each test function
            # is completed

        def testfunct1(self):
            # a test function

        def test_some_stuff(self):
            # another test function

    if __name__ == '__main__':
        unittest.main()


The ``unittest.TestCase`` class provides a number of functions to
test output during a test function.  For example:

``self.assertTrue(expr[,msg])``
    Test will fail if expr does not evaluate to True
    
``self.assertEqual(val1,val2)``
    Test will fail if val1 != val2
        
``self.assertNotEqual(val1,val2)``
    Test will fail if val1 == val2
        
``self.assertAlmostEqual(val1,val2[,places=7])``
    Test will fail if val1 differs from val2 by more than a small
    amount of decimal places.
    
``self.fail([msg])``
    Test will fail and display the given message
    
Often in a test you'll want to make sure that a specific exception is raised
when a certain thing happens, and usually you want to verify that the error
message contains certain information.  The unittest_ framework provides an
``assertRaises`` function that does part of this job, but it doesn't allow
you to check the error message, so the preferred way to test exceptions is
shown in the code below. In this example, we'll assume that the exception
we're interested in is a ``ValueError``, and note that we would place our
test function inside of our ``unittest.TestCase`` derived class.

.. parsed-literal::

    def test_myexception(self):
        try:
            # perform action here that should raise exception
        except ValueError, err:
            self.assertEqual(str(err), "this should be my expected error message")
        else:
            self.fail('expected a ValueError')

Note that the ``else`` block after the ``except`` is important because we
want the test to fail if no exception is raised at all.  Without the else
block, the test would pass if no exception was raised.


Test File Locations
+++++++++++++++++++

Unit tests are typically placed in a ``test`` subdirectory within the
directory where the source code being tested is located.  For example,
the test files for ``openmdao.main`` are located in
``openmdao.main/openmdao/main/test``.
        

Creating and Updating Package Distributions
-------------------------------------------

Sometimes the changes you make on your branch will result in the 
modification of an existing package or the creation of a new one. In
either case, you must create a distributable version for each new or
modified package.

In order for a python package to be distributable, you have to provide
a ``setup.py`` file that knows how to build, package, and install it. The
``setup.py`` file should be located in the top level directory of the
package. For instructions on how to create distributions, see the setuptools
`documentation <http://peak.telecommunity.com/DevCenter/setuptools>`_.

If a package contains code that must be compiled, you should create
a binary egg distribution for it for each of our release platforms, which are
currently *Windows*, *Linux*, and *OS X*.  To create a binary egg in the current
directory for the current platform, type the following:

::

   python setup.py bdist_egg -d .
   
This will generate an egg file with a name that contains information about
version of the package, platform, and the python version, e.g., 
``conmin-1.0-py2.5-linux-x86_64.egg``. 

Regardless of the contents of the package, you should also produce a source 
distribution of it. If you package has compiled code as mentioned above, you will
have to use the sdist command to generate a source tarball. Assuming your setup.py
file is written correctly, you can generate a source distribution in the current
directory by typing

::

   python setup.py sdist -d .
   
A gzipped tar file will be generated with the version number of the package
embedded in the filename, e.g., ``openmdao.recipes-0.1dev.tar.gz``

However, if your package does **not** contain any compiled code, you can 
simply use the ``python setup.py bdist_egg -d .`` command mentioned earlier 
to generate a source egg, which will have a name containing the package version 
information and the python version, e.g., ``openmdao.recipes-0.1dev-py2.5.egg``.


- TODO: describe needed metadata in setup.py file
- TODO: describe entry points used by the framework    


Creating New zc.buildout Recipes
================================

    - build an egg
    - zc.buildout entry points for each recipe
    - simple API
        - __init__(self, options, name, buildout)
        - install(self)  # returns list of files/dirs for later uninstall
        - update(self)
        - uninstall(self) # usually not necessary





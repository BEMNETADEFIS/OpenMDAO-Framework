
import sys
import os
import webbrowser

import pprint
import StringIO
from ConfigParser import SafeConfigParser
from optparse import OptionParser
from subprocess import call

from openmdao.util.fileutil import build_directory
from openmdao.util.dep import PythonSourceTreeAnalyser

from sphinx.setup_command import BuildDoc
import sphinx

templates = {}

# this is the template for the file that Sphinx uses to configure itself
templates['conf.py'] = """

# -*- coding: utf-8 -*-
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#

import sys, os

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 
              'sphinx.ext.doctest', 'sphinx.ext.todo','openmdao.util.doctools', 
              'sphinx.ext.viewcode'
      ]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'%(name)s'
copyright = u'%(copyright)s'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '%(version)s'
#The short version is the one that shows up in the file when you use /version/.
# The full version, including alpha/beta/rc tags.
release = '%(release)s'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%%B %%d, %%Y'

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%%b %%d, %%Y'

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

html_theme = "default"

# using these theme options will make the docs share a consistent
# look with the OpenMDAO docs
html_theme_options = {
     "headtextcolor": "darkred",
     "headbgcolor": "gainsboro",
     "headfont": "Arial",
     "relbarbgcolor": "black",
     "relbartextcolor": "white",
     "relbarlinkcolor": "white",
     "sidebarbgcolor": "gainsboro",
     "sidebartextcolor": "darkred",
     "sidebarlinkcolor": "black",
     "footerbgcolor": "gainsboro",
     "footertextcolor": "darkred",
     "textcolor": "black",
     "codebgcolor": "#FFFFCC",
     "linkcolor": "darkred",
     "codebgcolor": "#ffffcc",
    }

todo_include_todos = True

# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/dev': None}

autodoc_member_order = 'groupwise'

"""

templates['index.rst'] = """

%(title_marker)s
%(name)s Documentation
%(title_marker)s

Contents:

.. toctree::
   :maxdepth: 2
    
   usage
   srcdocs
   pkgdocs

  
"""


templates['srcdocs.rst'] = """

.. _%(name)s_src_label:


====================
Source Documentation
====================

.. automodule:: %(srcmod)s
   :members:
   :undoc-members:
   :show-inheritance:

"""


templates['usage.rst'] = """

===========
Usage Guide
===========

No usage information has been provided for this plugin. Consult the
:ref:`%(name)s_src_label` section for more detail.

"""


templates['setup.py'] = """

#
# This file is autogenerated during plugin_quickstart and overwritten during
# package_plugin. DO NOT CHANGE IT if you plan to use package_plugin to update 
# the distribution.
#

kwargs = %(setup_options)s

from setuptools import setup

setup(**kwargs)

"""

templates['MANIFEST.in'] = """

graft src/%(name)s/sphinx_build/html

"""

templates['README.txt'] = """

README.txt file for %(name)s.

To view the Sphinx documentation for this distribution, type:

plugin_docs %(name)s


"""

templates['setup.cfg'] = """

[metadata]
name = %(name)s
version = %(version)s
summary = 
description-file = README.txt
keywords = openmdao
home-page = 
download-url = 
author = 
author-email = 
maintainer = 
maintainer-email = 
license = 
classifier = Intended Audience :: Science/Research
    Topic :: Scientific/Engineering

requires-dist = openmdao.main
provides-dist = 
obsoletes-dist = 
requires-python = 
    >=2.6
    <2.7
requires-externals = 
project-url = 

"""

code_templates = {}

code_templates['openmdao.component'] = """

from openmdao.main.api import Component
from openmdao.lib.datatypes.api import Float


class %(classname)s(Component):
    \"\"\"  ... Make sure to put some kind of docstring here. Otherwise
                the descriptions for your variables won't show up in the
                source ducumentation.
    \"\"\"
    # declare inputs and outputs here
    x = Float(0.0, iotype='in', desc='description for x')
    y = Float(0.0, iotype='out', desc='description for y')

    def execute(self):
        # do your calculations here
        print 'hello'
        
"""

code_templates['openmdao.driver'] = """

from openmdao.main.api import Driver
from openmdao.util.decorators import add_delegate

class %(classname)s(Driver):
    \"\"\"  ... Make sure to put some kind of docstring here. Otherwise
                the descriptions for your variables won't show up in the
                source ducumentation.
    \"\"\"

    def start_iteration(self):
        super(%(classname)s, self).start_iteration()

    def continue_iteration(self):
        return super(%(classname)s, self).continue_iteration()
    
    def pre_iteration(self):
        super(%(classname)s, self).pre_iteration()
        
    def run_iteration(self):
        super(%(classname)s, self).run_iteration()

    def post_iteration(self):
        super(%(classname)s, self).post_iteration()

"""

code_templates['openmdao.variable'] = """
from openmdao.main.variable import Variable

class %(classname)s(Variable):

    #def __init__(self, default_value = ???, **metadata):
    #    super(%(classname)s, self).__init__(default_value=default_value,
    #                                        **metadata)

    def validate(self, object, name, value):
        pass
        # insert validation code here
        
        # in the event of an error, call
        # self.error(object, name, value)
"""


def get_pkgdocs(metadata):
    """Return a string in reST format that contains the metadata
    for the package.
    """
    lines = ['\n',
             '================\n',
             'Package Metadata\n',
             '================\n',
             '\n']

    tuplist = list(metadata.items())
    tuplist.sort()
    for key,value in tuplist:
        if value.strip():
            if '\n' in value:
                lines.append("- **%s**:: \n\n" % key)
                for v in [vv.strip() for vv in value.split('\n')]:
                    if v:
                        lines.append("    %s\n" % v)
                lines.append('\n')
            elif value != 'UNKNOWN':
                lines.append("- **%s:** %s\n\n" % (key, value))
        
    return ''.join(lines)


def argv_to_args(argv=None):
    """Convert command line arguments into arguments passable to a python
    callable.
    
    argv: str (optional)
        A list of argument strings.  If None (the default), then sys.argv[1:]
        will be used.
    
    Returns a tuple of the form (args, kwargs).
    """
    if argv is None:
        argv = sys.argv[1:]
        
    args = []
    kwargs = {}
    
    if len(argv) == 0:
        return (args, kwargs)

    for i,arg in enumerate(argv):
        if '=' in arg:
            break
        args.append(arg)
    else:
        return (args, kwargs)
        
    for arg in argv[i:]:
        if '=' in arg:
            lhs,rhs = arg.split('=',1)
            kwargs[lhs.strip()] = rhs.strip()
        else:
            raise RuntimeError("argv_to_args: positional arg (%s) appeared after named args" %
                               arg)
    
    return (args, kwargs)


def _get_setup_options(metadata):
    # mapping of new metadata names to old ones
    mapping = {
        'name': 'name',
        'version': 'version',
        'keywords': 'keywords',
        'summary': 'description',
        'description': 'long_description',
        'home-page': 'url',
        'download-url': 'download_url',
        'author': 'author',
        'author-email': 'author_email',
        'maintainer': 'maintainer',
        'maintainer-email': 'maintainer_email',
        'license': 'license',
        'classifier': 'classifiers',
        'requires-dist': 'install_requires',
        'entry_points': 'entry_points',
        }
    
    setup_options = {
        'packages': [metadata['name']],
        'package_data': { metadata['name']: [
            'sphinx_build/html/*.*',
            'sphinx_build/html/_modules/*',
            'sphinx_build/html/_sources/*',
            'sphinx_build/html/_static/*',
            ] },
        'package_dir': {'': 'src'},
        'zip_safe': False,
        'include_package_data': True,
    }
    
    for key,val in metadata.items():
        if key in mapping:
            setup_options[mapping[key]] = val

    return setup_options

def plugin_quickstart(argv=None):
    """A command line script (plugin_quickstart) points to this.  It generates a
    directory structure for an openmdao plugin package along with Sphinx docs.
    
    usage: plugin_quickstart <plugin_class_name> [-v <version>] [-d <dest_dir>] [-g <plugin_group>] [--dist=<dist_name>]
    
    """
    
    if argv is None:
        argv = sys.argv[1:]
    
    parser = OptionParser()
    parser.usage = "plugin_quickstart <plugin_class_name> [options]"
    parser.add_option("-v", "--version", action="store", type="string", dest='version', default='0.1',
                      help="version id of the plugin (optional)")
    parser.add_option("", "--dist", action="store", type="string", dest='dist',
                      help="distribution name (optional)")
    parser.add_option("-d", "--dest", action="store", type="string", dest='dest', default='.',
                      help="directory where new plugin directory will be created (optional)")
    parser.add_option("-g", "--group", action="store", type="string", dest='group', 
                      default = 'openmdao.component',
                      help="specify plugin group (openmdao.component, openmdao.driver, openmdao.variable) (optional)")
    
    (options, args) = parser.parse_args(argv)

    if len(args) < 1 or len(args) > 2:
        parser.print_help()
        sys.exit(-1)

    classname = args[0]
    if options.dist:
        name = options.dist
    else:
        name = classname.lower()
    version = options.version
    
    setup_options = _get_setup_options({ 'name':name, 'version':version })
    
    sio = StringIO.StringIO()
    pprint.pprint(setup_options, sio)
    
    template_options = {
        'release': version,
        'classname': classname,
        'copyright': '',
        'summary': '',
        'title_marker': '='*(len(name)+len(' Documentation')),
        'setup_options': sio.getvalue()
    }
    
    options.dest = os.path.expandvars(os.path.expanduser(options.dest))

    startdir = os.getcwd()
    try:
        os.chdir(options.dest)
        
        cfg = SafeConfigParser()
        stream = StringIO.StringIO(templates['setup.cfg'] % { 'name':name, 'version':version })
        cfg.readfp(stream, 'setup.cfg')
        cfgcontents = StringIO.StringIO()
        cfg.write(cfgcontents)
        
        metadata = dict([item for item in cfg.items('metadata')])
        template_options.update(metadata)
        
        plugin_py_template = code_templates[options.group]
        pycontents = plugin_py_template % template_options
        pyfile = '%s.py' % name
        template_options['srcmod'] = name
    
        dirstruct = {
            name: {
                'setup.py': templates['setup.py'] % template_options,
                'setup.cfg': cfgcontents.getvalue(),
                'MANIFEST.in': templates['MANIFEST.in'] % template_options,
                'README.txt': templates['README.txt'] % template_options,
                'src': {
                    name: {
                        '__init__.py': 'from %s import %s\n' % (name,classname),
                        pyfile: pycontents,
                        },
                    },
                'docs': {
                    'conf.py': templates['conf.py'] % template_options,
                    'index.rst': templates['index.rst'] % template_options,
                    'srcdocs.rst': templates['srcdocs.rst'] % template_options,
                    'pkgdocs.rst': get_pkgdocs(metadata),
                    'usage.rst': templates['usage.rst'] % template_options,
                    },
            },
        }

        build_directory(dirstruct)
    
    finally:
        os.chdir(startdir)

        
def _verify_dist_dir(dpath):
    """Try to make sure that the directory we've been pointed to actually
    contains a distribution.
    """
    if not os.path.isdir(dpath):
        raise IOError("directory '%s' does not exist" % dpath)
    
    expected = ['src', 'docs', 'setup.py', 'setup.cfg', 'MANIFEST.in',
                os.path.join('docs','conf.py'),
                os.path.join('docs','index.rst'),
                os.path.join('docs','srcdocs.rst')]
    for f in expected:
        if not os.path.exists(os.path.join(dpath, f)):
            raise IOError("directory '%s' does not contain '%s'" %
                          (dpath, f))

        
#
# FIXME: this still needs some work, but for testing purposes it's ok for now
#
def _find_all_plugins(searchdir):
    """Return a dict containing lists of each plugin type found, keyed by
    plugin group name, e.g., openmdao.component, openmdao.variable, etc.
    """
    dct = {}
    psta = PythonSourceTreeAnalyser(searchdir)
    
    comps = psta.find_inheritors('openmdao.main.component.Component')
    comps.extend(psta.find_inheritors('openmdao.main.api.Component'))
    comps = set(comps)
    
    drivers = psta.find_inheritors('openmdao.main.driver.Driver')
    drivers.extend(psta.find_inheritors('openmdao.main.api.Driver'))
    drivers = set(drivers)
    
    comps = comps - drivers
    
    dct['openmdao.component'] = comps
    dct['openmdao.driver'] = drivers
    
    variables = psta.find_inheritors('openmdao.main.api.Variable')
    variables.extend(psta.find_inheritors('openmdao.main.variable.Variable'))
    dct['openmdao.variable'] = set(variables)

    return dct


def package_plugin(argv=None):
    """A command line script (package_plugin) points to this.  It creates a 
    source distribution containing sphinx documentation for the specified
    distribution directory.  If no directory is specified, the current directory
    is assumed.
    
    usage: package_plugin [dist_dir_path]
    
    """
    
    if argv is None:
        argv = sys.argv[1:]
        
    if len(argv) == 0:
        destdir = os.getcwd()
    elif len(argv) == 1:
        destdir = os.path.abspath(os.path.expandvars(os.path.expanduser(argv[0])))
    else:
        raise RuntimeError("\nusage: package_plugin [dist_dir_name]\n")

    _verify_dist_dir(destdir)

    startdir = os.getcwd()
    os.chdir(destdir)
    
    try:
        cfg = SafeConfigParser()
        cfg.readfp(open('setup.cfg', 'r'), 'setup.cfg')
        metadata = dict([item for item in cfg.items('metadata')])
        plugins = _find_all_plugins('src')
        entrypoints = {}
        for key,val in plugins.items():
            epts = []
            for v in val:
                mod,cname = v.rsplit('.', 1)
                epts.append('%s.%s=%s:%s' % (mod,cname,mod,cname))
            if epts:
                entrypoints[key] = epts
        
        pkgdocs = get_pkgdocs(metadata)
        
        metadata['entry_points'] = entrypoints

        if 'release' not in metadata:
            metadata['release'] = metadata['version']
            
        sio = StringIO.StringIO()
        pprint.pprint(_get_setup_options(metadata), sio)
        metadata['setup_options'] = sio.getvalue()

        dirstruct = {
            'setup.py': templates['setup.py'] % metadata,
            'docs': {
                'pkgdocs.rst': pkgdocs,
                },
            }
        
        disttar = "%s-%s.tar.gz" % (metadata['name'],metadata['version'])
        disttarpath = os.path.join(startdir, disttar)
        if os.path.exists(disttarpath):
            sys.stderr.write("ERROR: distribution %s already exists.\n" % disttarpath)
            sys.exit(-1)
        
        build_directory(dirstruct, force=True)
        
        docdir = os.path.join(destdir, 'docs')
        srcdir = os.path.join(destdir, 'src', metadata['name'])
        if srcdir not in sys.path:
            sys.path[0:0] = [srcdir]
            
        sphinx.main(argv=['-P','-b', 'html',
                          '-Dversion=%s' % metadata['version'],
                          '-Drelease=%s' % metadata['version'],
                          '-d', os.path.join(srcdir, 'sphinx_build', 'doctrees'), 
                          docdir, 
                          os.path.join(srcdir, 'sphinx_build', 'html')])

        cmdargs = [sys.executable, 'setup.py', 'sdist', '-d', startdir]
        cmd = ' '.join(cmdargs)
        retcode = call(cmdargs)
        if retcode:
            sys.stderr.write("\nERROR: command '%s' returned error code: %s\n" % (cmd,retcode))
    finally:
        os.chdir(startdir)

    if os.path.exists(disttar):
        print "Created distribution %s" % disttar
    else:
        sys.stderr.write("\nERROR: failed to make distribution %s" % disttar)


def _plugin_docs(argv=None):
    """A command line script (plugin_docs) points to this. It brings up
    the sphinx documentation for the named plugin in a browser.
    """
    if argv is None:
        argv = sys.argv[1:]
        
    if len(argv) != 1:
        print 'usage: plugin_docs <plugin_name>'
        sys.exit(-1)
        
    if len(argv) > 1:
        browser = argv[1]
    else:
        browser = None
        
    plugin_docs(argv[0], browser)
        
        
def plugin_docs(plugin_name, browser=None):
    """This brings up the sphinx docs for the named plugin using the
    specified browser.  The plugin must be importable in the current 
    environment.
    
    plugin_name: str
        Name of the plugin.
        
    browser: str (optional)
        Name of the browser (according to the webbrowser library) to
        use to view the plugin docs.  If none is specified, the platform
        default browser will be used.
    """
    try:
        mod = __import__(plugin_name)
    except ImportError:
        raise RuntimeError("Can't locate plugin '%s'" % plugin_name)
    
    idx = os.path.join(os.path.dirname(os.path.abspath(mod.__file__)),
                       'sphinx_build', 'html', 'index.html')
    
    if not os.path.isfile(idx):
        raise RuntimeError("Cannot locate index file for plugin '%s'" % plugin_name)
    
    wb = webbrowser.get(browser)
    wb.open(idx)

if __name__ == '__main__':
    package_plugin(['/OpenMDAO/dev/banaylor/T441_plugin_docs/devenv/foo'])
    

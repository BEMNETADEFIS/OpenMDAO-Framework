

#include <InterpIncludes.ncp>

class newShaft extends Element {

//------------------------------------------------------------
//     ******* DOCUMENTATION *******
//------------------------------------------------------------

 description = "The "+isA() +" element provides basic mechanical connections between rotating 
elements such as turbines and compressors.  The Shaft element is responsible for
providing a power balance between all components connected to it.";

 usageNotes = isA() + 
"

- The shaft element can have any number of mechanical ports attached to it.  
These ports are declared at run time when the element is created.

- In steady-state mode the solver will vary the shaft mechanical speed to 
balance the input ports torque with the output ports torque.

- In transient mode the mechanical speed is varied until the mechanical speed 
set by the solver is equal to the mechanical speed determined by integrating 
the acceleration determined from the net torque.

- Note that the shaft has only input mechanical ports, they are connected to 
compressor, turbine, and load component output mechanical ports.

- Each port is looked at and its torque summed in either trqPos or trqNeg 
depending on whether it is greater or less than 0.

- trqNet = trqIn * ( 1 - fracLoss ) + trqOut - HPX / ( Nmech * 2*PI/60/550 );

- The power terms are next calculated from the torque terms: 
pwr = trq * Nmech * 2*PI/60/550;

- If the inertiaSum is non-zero then an acceleration is calculated: 
dNqdt = ( trqNet / inertiaSum ) * 60/(2*PI)";



//------------------------------------------------------------
//     ******* SETUP VARIABLES ********
//------------------------------------------------------------

  real dNqdt {
    value = 0;  IOstatus = OUTPUT;  units = RPM_PER_SEC;
    description = "Derivative of speed with respect to time - acceleration";
  }
  real fracLoss {
    value = 0;  IOstatus = INPUT;  units = NONE;
    description = "Fractional loss on the positive port torque (see Usage
Notes)";
  }
  real HPX {
    value = 0;  IOstatus = INPUT;  units = HORSEPOWER;
    description = "Horsepower extracted from the shaft";
  }
  real inertia {
    value = 0;  IOstatus = INPUT;  units = SLUG_FT2;
    description = "Inertia of the shaft itself";
  }
  real inertiaSum {
    value = 0;  IOstatus = OUTPUT;  units = SLUG_FT2;
    description = "Total inertia of the shaft and attached components";
  }
  real Nmech {
    value = 0;  IOstatus = INPUT;  units = RPM;
    description = "Mechanical speed of the shaft";
  }
  real pwrIn {
    value = 0;  IOstatus = OUTPUT;  units = HORSEPOWER;
    description = "Total of all positive horsepower at the shaft ports";
  }
  real pwrNet {
    value = 0;  IOstatus = OUTPUT;  units = HORSEPOWER;
    description = "Total of all power on the shaft";
  }
  real pwrOut {
    value = 0;  IOstatus = OUTPUT;  units = HORSEPOWER;
    description = "Total of all power coming off the shaft";
  }
  real trqIn {
    value = 0;  IOstatus = OUTPUT;  units = FT_LBF;
    description = "Total of all torques coming into the shaft";
  }
  real trqNet {
    value = 0;  IOstatus = OUTPUT;  units = FT_LBF;
    description = "Net total of all torques on the shaft and losses
(see Usage Notes)";
  }
  real trqOut {
    value = 0;  IOstatus = OUTPUT;  units = FT_LBF;
    description = "Total of all negative torques at shaft ports";
  }

//------------------------------------------------------------
//   ******* OPTION VARIABLE SETUP *******
//------------------------------------------------------------

  Option switchDes {
    allowedValues = { DESIGN, OFFDESIGN }
    description = "Design mode switch indicator [ DESIGN / OFFDESIGN ]";
    rewritableValues = FALSE;  // Enables converter optimization.
  }

//------------------------------------------------------------
// ****** SETUP PORTS, FLOW STATIONS, SOCKETS, TABLES ********
//------------------------------------------------------------

  // FLUID PORTS

  // FUEL PORTS

  // BLEED PORTS

  // THERMAL PORTS

  // MECHANICAL PORTS
  string shaftPortList[];
  shaftPortList.ptrType = "ShaftInputPort";

  // FLOW STATIONS

  // SOCKETS

  // TABLES

//------------------------------------------------------------
// ******* INTERNAL SOLVER SETUP *******
//------------------------------------------------------------

//------------------------------------------------------------
//  ******  ADD SOLVER INDEPENDENTS & DEPENDENTS  ******
//------------------------------------------------------------

  Independent ind_Nmech {
    varName = "Nmech";
    description = "Default independent to vary mechanical speed";
  }

  Integrator integrate_Nmech {
    stateName = "Nmech";
    derivativeName = "dNqdt";
    eq_lhs = "trqNet";
    eq_rhs = "0.0000";
    eq_Ref = "trqIn";
    description = "Default integrator to balance out the net torques";
    autoSetup = TRUE;
  }

//------------------------------------------------------------
// ******* VARIABLE CHANGED METHODOLOGY *******
//------------------------------------------------------------
  void variableChanged( string name, any oldVal ) {

    integrate_Nmech.autoSetup = TRUE;

    if ( name == "switchDes" ) {

      if ( switchDes == "DESIGN" ) {
        ind_Nmech.autoSetup = FALSE;
      }   
      else if ( switchDes == "OFFDESIGN" ) {
        ind_Nmech.autoSetup = TRUE;
      }
    }
  }

//------------------------------------------------------------
//   ******* PERFORM ENGINEERING CALCULATIONS *******
//------------------------------------------------------------
  void calculate() {

    //------------------------------------------------------------
    // Set initial value of inertiaSum to be shaft inertia
    //------------------------------------------------------------
    inertiaSum = inertia;

    //------------------------------------------------------------
    // Iterate through the shaft port list to sum torques
    // supplied and extracted from the shaft and to sum all
    // shaft components intertias
    //------------------------------------------------------------
    trqIn  = 0.0;
    trqOut = 0.0;

    int i;

    for( i=0; i<shaftPortList.entries(); ++i ) {

      //------------------------------------------------------------
      // Sum all shaft component inertias
      //------------------------------------------------------------
      inertiaSum = inertiaSum + shaftPortList[i]->getInertia();

      //------------------------------------------------------------
      // Sum torques supplied to the shaft (positive)
      //------------------------------------------------------------
      if ( shaftPortList[i]->getTrq() > 0 ) {
        trqIn  = trqIn  + shaftPortList[i]->getTrq();
      }

      //------------------------------------------------------------
      // Sum torques extracted from the shaft (negative)
      //------------------------------------------------------------
      else if ( shaftPortList[i]->getTrq() < 0 ) {
              trqOut = trqOut + shaftPortList[i]->getTrq();
      }
    }

    //------------------------------------------------------------
    // Calculate net torque on the shaft
    //------------------------------------------------------------
    real convert = 2. * PI / 60. / C_HPtoFT_LBF_PER_SEC;
    trqNet = trqIn * ( 1 - fracLoss )  + trqOut - HPX / ( Nmech * convert );

    //------------------------------------------------------------
    // Calculate powers supplied and extracted from the shaft and
    // the resulting net power
    //------------------------------------------------------------
    pwrNet = trqNet * Nmech * convert;
    pwrOut = trqOut * Nmech * convert;
    pwrIn  = trqIn  * Nmech * convert;

    //------------------------------------------------------------
    // Calculate speed derivative if inertiaSum is not 0
    //------------------------------------------------------------
    if ( inertiaSum != 0. ) {
      dNqdt = ( trqNet / inertiaSum ) * 60. / ( 2. * PI );
    }
  }
  
  
  void VCinit() {
    int i; 
    int portCount = shaftPortList.entries();
    for(i=0;i<portCount;i++) {
      shaftPortList[i]->setSpeedRef( "." + parent.getPathName() + ".Nmech" ); 
    }
  }

  //------------------------------------------------------------
  // Function allows for creation of shaft input ports
  //------------------------------------------------------------
  void postcreate( string name ) {

    if(name->hasInterface("ShaftInputPort")) {
      shaftPortList.append( name );
    }
  }

}

#ifdef __NPSSCONVERTER__
_STD_C_INCLUDES += "\n#include <ShaftInputPort.H>";
#endif



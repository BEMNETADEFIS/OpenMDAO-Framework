MixedTurboFan engine;
MODELNAME = "SBJ_models_1-17-08";
engine.init(); // initialization routine for the engine is necessary, do not delete!

// Check the output in this file to test for failed case
//     if failed = 0; Then your ok!
//     if failed = 1; Then your design did not converge
//     an explaination will be included in the file
//     ** ignore failure messages printed to the screen, they are intermediate cases
OutFileStream failCheck { filename = "failureCheck.out"; }

// Set Design Variables Here
engine.FanPRdes = 2.51;
engine.HpcPRdes = 8.00;
engine.TOCThrust = 5230;
engine.Knoz = 1.04; 
engine.saveKnoz = engine.Knoz; 
  //This setting regulates the underexpansion of the nozzle
  //Knoz equals %nozzle exit static pressure below ambient
  //Knoz automatically gets reset to 1 below ambient Mach 1 for all cases

// Don't Touch Below Here!!: 

// Define Throttle Hook Run Function
real failCount  = 0;
void runThrottleHook(real altitude, real Mach) {
  // Note: Only successfull Throttle Hooks are recorded in the deck
  int maxPowerSuccess = TRUE;
  int throttleHookFailure = 0;
  engine.alt = altitude;
  engine.MN = Mach;
  maxPowerSuccess = TRUE;
 
  
  engine.PC = 50;
  engine.setup();
  engine.run();
  engine.page.display();
  if(engine.solver.converged == TRUE) {engine.FLOPsheet.update();}
  else{ 
    maxPowerSuccess = FALSE; 
    return;
  }
  
  engine.PC = 45;
  engine.setup();
  engine.run();
  engine.page.display();
  if(engine.solver.converged == TRUE && maxPowerSuccess) {engine.FLOPsheet.update();}
  else {throttleHookFailure += 1;}
  
  
  engine.PC = 40;
  engine.setup();
  engine.run();
  engine.page.display();
  if(engine.solver.converged == TRUE && maxPowerSuccess) {engine.FLOPsheet.update();}
  else {throttleHookFailure += 1;}
  
  engine.PC = 30;
  engine.setup();
  engine.run();
  engine.page.display();
  if(engine.solver.converged == TRUE && maxPowerSuccess) {engine.FLOPsheet.update();}
  else {throttleHookFailure += 1;}
  
  engine.PC = 40;
  engine.setup();
  engine.run();
  
  engine.PC = 50;
  engine.setup();
  engine.run();  
  
  if(throttleHookFailure >=3) {
    // If too many power codes fail, fail the whole throttle hook
    failCount += 1;
  }
}

int mcReload = FALSE;

string mcInputs[] = {
   "engine.alt",
   "engine.extractionRatio",
   "engine.FanPRdes",
   "engine.HpcPRdes",
   "engine.Knoz",
   "engine.MN",
   "engine.nozzle.Cfg",
   "engine.TOCThrust"
};

void mcRun() {
   int i;
   cout << "\nMC_SLS mcRun() executing in " << getcwd() << endl;

   LocalOutFileStream out;
   out.open("NPSS_SLS.textRep");
   out << .getTextRep(TRUE);
   out.close();

   for (i = 0 ; i < mcInputs.entries() ; ++i) {
     cout << "    " << mcInputs[i] << " = " << mcInputs[i]->value << endl;
   }

   // This model needs a reload after the initial run.
   mcReload = TRUE;

   // Do the stuff associated with running the model.
   parseFile("MC_SLS.run");

   // Display data viewers and set-up for a new run's display.
   string dataViewers[] = list("DataViewer", TRUE);
   for (i = 0 ; i < dataViewers.entries() ; ++i) {
     string dataViewer = dataViewers[i];
     dataViewer->display();
     dataViewer->reset();

     // Reset the filename to start a new output file.
     // Without this, rerunning a model will append to the file.
     // This is not necessary if the model is reloaded.
     string prefix = "";
     if (dataViewer->outStreamHandle[0] != ".") {
       // Not absolute, so get context.
       string path = dataViewer;
       int dot;
       while ((dot = path.index(".")) > 0) {
         prefix += path.substr(0, dot+1);
         path = path.substr(dot+1, -1);
       }
     }
     string handle = prefix+dataViewer->outStreamHandle;
     handle->filename = handle->filename;
   }

   cout.flush();
   cerr.flush();
}

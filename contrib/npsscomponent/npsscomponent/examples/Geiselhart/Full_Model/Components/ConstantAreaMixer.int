// ****************************************************************************
// * NASA Glenn Research Center
// * 21000 Brookpark Rd
// * Cleveland, OH 44135
// *
// * NPSS NICE-1 Proprietary Information
// * Do not release outside of the NICE-1 Government/Industry team members
// ****************************************************************************

#include <InterpIncludes.ncp>

class ConstantAreaMixer extends Element {

//------------------------------------------------------------
//     ******* DOCUMENTATION *******
//------------------------------------------------------------

  title =
" MIXER ELEMENT

              -----------------------
             |                      |
   Fl_I1 --->|                      |
             |        Mixer2        |---> Fl_O
   Fl_I2 --->|                      |
             |                      |
              -----------------------
               |        |         |
               V        V         V
    socket: S_Cmix   S_dImp    S_partMix
socketType:  CMIX     CIMP       CPMIX
   returns:  Cmixer  a_Impulse  partialMix

";
  description = isA() + " will calculate the performance of a two-stream constant-area mixer.";

  usageNotes = isA() +
  "
  No Provisional Errors or Warnings.

  The mixer conserves energy, continuity, and momentum when mixing two streams
  into one.  At design point the user needs to provide a Mach number for
  the primary entrance flow.  This Mach number determines the primary
  entrance area.  The secondary entrance area is determined by varying
  the Mach number until the static pressure of the two streams is
  equal.  The exit area is determined by adding the two entrance areas
  together (constant area mixer).

  For off-design execution, where the area of the secondary entrance
  area is held constant, the mixer specifies a Dependent for use in the
  Solver that is converged when the static pressure of the the two
  entrance streams are equal. The mixer, however, does not contain a
  parameter that can be used as an Independent that the Solver can vary
  to balance the static pressures. The user must, either, make sure the
  Model contains an additional Independent from an element, such as a
  Splitter upstream of the Mixer, or manually specify an Independent
  that will effect the static pressure error.

  The mixer has a socket for calculating a partial mixing thrust correction.
  This value can be fed into a nozzle and used in the thrust calculations.

  The mixer also has a socket for calculating an adder that is applied to the
  incoming impulse terms (both pressure force and momentum).  This number can
  be used to account for losses occurring inside the mixer.

  Finally, the mixer has a socket for calculating a coefficient which
  is applied only to incoming momentum terms (incoming pressure force terms
  are not affected).  This term can also be used to account for losses
  inside the mixer.


  ";


  background =
"
  This element is a re-write of the original element provided by Mike
  Binder.  It was changed significantly to simplify it.  The original
  mixer allowed any number of entrance ports.  However, this flexibility
  made the element complex and difficult to work with for the standard
  case of two inputs and one output.

";

//------------------------------------------------------------
//     ******* SETUP VARIABLES ********
//------------------------------------------------------------

  real a_Impulse {
    value = 0;  IOstatus = INPUT;  units = LBF;
    description = "Adder to be applied to incoming impulse (calculated by socket S_dImp)";
  }
  real Aout {
    value = 0;  IOstatus = OUTPUT;  units = INCH2;
    description = "Exit area";
  }
  real Cmixer {
    value = 1;  IOstatus = INPUT;  units = NONE;
    description = "Scale factor applied to the incoming momentum terms (calculated by socket S_Cmix)";
  }
  real impMixed {
    value = 0;  IOstatus = OUTPUT;  units = LBF;
    description = "Total impulse of the two incoming streams (pressure force + momentum)";
  }
  real impOut {
    value = 0;  IOstatus = OUTPUT;  units = LBF;
    description = "Total impulse of the two exiting streams (pressure force + momentum)";
  }
  real partialMix {
    value = 1;  IOstatus = INPUT;  units = NONE;
    description = "Partial mixing correction term (calculated by socket S_partMix)";
  }
  real PsI1 {
	 value = 1;  IOstatus = INPUT;  units = PSIA;
    description = "Inlet 1 static pressure";
  }
  real PsI2 {
	 value = 1;  IOstatus = INPUT;  units = PSIA;
    description = "Inlet 2 static pressure";
  }
  real PtOut {
	 value = 1;  IOstatus = INPUT;  units = PSIA;
    description = "Exit total pressure. Controlled by the independent ind_PtOut";
  }
  real PtRatio {
	 value = 1;  IOstatus = OUTPUT;  units = NONE;
    description = "Ratio of Fl_I1 Pt to Fl_I2 Pt";
  }


//------------------------------------------------------------
//   ******* OPTION VARIABLE SETUP *******
//------------------------------------------------------------
// Option switch default value is first value in allowedValue list
  Option switchDes {
    allowedValues = { DESIGN, OFFDESIGN }
    description = "Design/Off-Design switch";
  }

//------------------------------------------------------------
// ****** SETUP PORTS, FLOW STATIONS, SOCKETS, TABLES ********
//------------------------------------------------------------

  // FLUID PORTS

  FluidInputPort Fl_I1 {
    description = "Primary incoming flow stream (design pt sizing flow)";
  }

  FluidInputPort Fl_I2 {
    description = "Secondary incoming flow stream";
  }

  FluidOutputPort Fl_O {
    description = "Outgoing flow";
  }

// FUEL PORTS

// BLEED PORTS

// THERMAL PORTS

// MECHANICAL PORTS

// FLOW STATIONS

// SOCKETS

  Socket S_Cmix {
    allowedValues = { "Cmixer" }
    description = "Socket returns scale factor applied to the incoming momentum terms";
    socketType = CMIX;
  }

  Socket S_dImp {
    allowedValues = { "a_Impulse" }
    description = "Socket returns adder to be applied to incoming impulse";
    socketType = CIMP;
  }

  Socket S_partMix {
    allowedValues = { "partialMix" }
    description = "Socket returns partial mixing correction term ";
    socketType = CPMIX;
  }

// TABLES
//------------------------------------------------------------
//  ******  ADD SOLVER INDEPENDENTS & DEPENDENTS  ******
//------------------------------------------------------------

  Independent ind_PtOut {
	 varName = "PtOut";
	 description = "Vary the exit total pressure";
	 autoSetup = TRUE;
  }

  Independent ind_MN1 {
    varName = "Fl_I1.MN";
    autoSetup = FALSE;
  }

  Independent ind_MN2 {
  	varName = "Fl_I2.MN";
  	autoSetup = FALSE;
  }

  Dependent dep_constArea {
  	eq_lhs = "Fl_O.Aphy";
  	eq_rhs = "Fl_I1.Aphy+Fl_I2.Aphy";
  	autoSetup = FALSE;
  }

  Dependent dep_errImp {
    eq_lhs = "impMixed";
    eq_rhs = "impOut";
    description = "Error between mixed inlet flow impulse and exit condition impulse";
	 autoSetup = TRUE;
  }

  Dependent dep_errPs {
    eq_lhs = "PsI1";
    eq_rhs = "PsI2";
    description = "Pressure balance error";
  }



//------------------------------------------------------------
// ******* INTERNAL SOLVER SETUP *******
//------------------------------------------------------------

  //------------------------------------------------------------
  // Define the secant solver required for the Mach iterations
  //------------------------------------------------------------
  SecantSolver iterMN {
    description = "solver for exit total pressure";
    maxDx = 0.2;
    tolerance = 1.E-5;  // tolPs
    perturbSize = 0.01;
    maxIters = 50;
  }


  //------------------------------------------------------------
  // ******* VARIABLE CHANGED METHODOLOGY *******
  //------------------------------------------------------------

  void variableChanged( string name, any oldVal ) {

    //------------------------------------------------------------
    // Turn the automatic solver on and off depending on the
    // Design mode
    //------------------------------------------------------------
    if ( name =="switchDes" ) {
		if ( switchDes == DESIGN ) {
		  dep_errPs.autoSetup = FALSE;
		  dep_constArea.autoSetup = FALSE;
		  ind_MN1.autoSetup = FALSE;
		  ind_MN2.autoSetup = FALSE;
      }
      else if ( switchDes == OFFDESIGN ) {
		  dep_errPs.autoSetup = TRUE;
		  dep_constArea.autoSetup = TRUE;
		  ind_MN1.autoSetup = TRUE;
		  ind_MN2.autoSetup = TRUE;

      }
    }
  }

//------------------------------------------------------------
//   ******* PERFORM ENGINEERING CALCULATIONS *******
//------------------------------------------------------------

  void VCinit() {
  	PtOut = Fl_I1.Pt;
  }
  void calculate() {

    //--------------------------------------------------------
    // If we are in desi      desArea = Aout;gn mode, determine the secondary
    // flow static conditions
    //--------------------------------------------------------

    if ( switchDes == DESIGN ){

      //---------------------------------------------------------
      // Determine the secondary flow area that will match the
      // secondary static pressure to the primary static pressure
      //---------------------------------------------------------

      //start the Mach number with a guess of .4
      real Mach = .4;

      //iterate until the secondary static pressure equals the
      //primary static pressure
      //cout << "Fl_I2:" << Fl_I2.MN << endl;
      //cout << "Fl_I1:" << Fl_I1.MN << endl <<endl; quit();
      iterMN.initialize( Mach );
      
      do {
		  Fl_I2.MN = Mach;
		  Mach =  iterMN.iterate(  ( Fl_I2.Ps - Fl_I1.Ps ) / PSTD );
      } while ( !( iterMN.isConverged() )&&!( iterMN.errorType ));

      //---------------------------------------------------------
      // Determine the exit area by adding the two entrance
      // streams (constant area mixer assumption)
      //---------------------------------------------------------
      Aout = Fl_I1.Aphy + Fl_I2.Aphy;

      Fl_O.Aphy = Aout;
      
    }

	 //--------------------------------------------------------
	 // copy the static pressure out of the fluid inlet ports
	 // to PsI1 and PsI2
	 //--------------------------------------------------------

	 PsI1 = Fl_I1.Ps;
   PsI2 = Fl_I2.Ps;
   

	 //-----------------------------------------------------------
    // Calculate the ratio of the inlet total pressures
    //-----------------------------------------------------------

	 PtRatio = Fl_I1.Pt/Fl_I2.Pt;

    //-----------------------------------------------------------
    // Perform an energy balance on the two streams using the
    // FlowStation copy and add functions
    //-----------------------------------------------------------
    Fl_O.copyFlow( "Fl_I1" );
    Fl_O.add( "Fl_I2" );


	 //------------------------------------------------------------
	 // Set the exit total pressure
	 //------------------------------------------------------------
	 Fl_O.setTotal_hP( Fl_O.ht, PtOut );

	 //------------------------------------------------------------
	 // Execute the sockets to provide corrections on the
	 // incoming impulse term
	 //------------------------------------------------------------
	 if ( !S_Cmix.isEmpty() ){
		S_Cmix.execute(); }
	 if ( !S_dImp.isEmpty() ){
		S_dImp.execute();}
	 if ( !S_partMix.isEmpty() ){
		S_partMix.execute();}

	 //------------------------------------------------------------
	 // Determine the incoming impulse term
	 //------------------------------------------------------------
	 impMixed = ( Fl_I1.Ps * Fl_I1.Aphy + Fl_I2.Ps * Fl_I2.Aphy ) +
		Cmixer * ( Fl_I1.W * Fl_I1.Vflow + Fl_I2.W * Fl_I2.Vflow )/ GRAVITY
		- a_Impulse;

	 //------------------------------------------------------------
	 // Determine the exit impulse term
	 //------------------------------------------------------------
	 impOut = Fl_O.Ps * Fl_O.Aphy + Fl_O.W * Fl_O.Vflow / GRAVITY;
  }
}


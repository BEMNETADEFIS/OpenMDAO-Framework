class MixedTurboFan extends Model {
  setThermoPackage("GasTbl");
  // Model Level Variables
  int designFlag {
    value = 1;
    description = "flag indicating design or off design analysis: 1=Design, 0= OffDesign";
    trigger = 1;
  }
  real PC{
    value = 50; 
    trigger = 1;
  }

  real maxThrust;
  real extractionRatio = 1.05;
  real T4Max = 3500;
  real TOCThrust = 7000;
  
  int success = 1;
  int succeeded() {
    return success;
  }
  
  // Model Level Independents and Dependents
  Dependent dep_TOCFnDes{
    eq_lhs = "PERF.Fn";
    eq_rhs = "TOCThrust";
  }
  
  Independent ind_BPR {
    varName = "split.BPR";
    description = "Bypass Ratio";
  }
  // used in off design operation
  Dependent dep_fixedGeomMixer {
    eq_lhs = "mixer.desArea";
    eq_rhs = "mixer.Fl_I1.Aphy";
  }
  Dependent dep_exRatio {
    eq_lhs = "PERF.extractionRatio";
    eq_rhs = "extractionRatio";
  }
  
  
  Independent ind_FAR {
    varName = "burner.FAR";
  }
  Dependent dep_FanNc {
    eq_lhs = "fan.S_map.NcMap";
    eq_rhs = "1.05";
  }
  Table AoAcMax(real MN) {
    MN={0.5338,0.6779,0.8576,0.9311,0.9959,1.0982,1.2955,1.5267,1.6905,1.9885}
    AoAc_Dist={0.9990,0.8695,0.7765,0.7581,0.7499,0.7553,0.7866,0.8416,0.8872,0.9480}
  }
  Dependent dep_AoAcmax {
    eq_lhs = "inlet.S_install.A0";
    eq_rhs = "AoAcMax(ambient.ZMN)";
  }
  Dependent dep_T4max {
    eq_lhs = "burner.Fl_O.Tt";
    eq_rhs = "T4Max";
    addConstraint("dep_FanNc","MAX");
    //addConstraint("dep_AoAcmax","MAX");
  }  
  Dependent dep_Thrust{
    eq_lhs = "PERF.Fn/maxThrust";
    eq_rhs = "PC/50";
  }
  
  // Take Off Thrust
  Dependent dep_SLSThrust {
    eq_lhs = "23000";
    eq_rhs = "PERF.FN";
  }
  
  // Model Level Functions
  void initialize() {
    create("","OutFileStream","pageStream");
    pageStream.filename = "engine.out"; 
    //OutFileStream pageStream {filename = "engine.out";}
    parseFile("MDP.view");      
    parseFile("flops.view");
  }
  
  void setup() {
    ESOregSetActive( 2004299, FALSE );
    solver.maxJacobians = 50;
    solver.maxIterations = 150;
    //solver.solutionMode = "ONE_PASS";
    
    if(ambient.ZMN < 1) {
      Knoz = 1;
    }
    
    autoSolverSetup(); 
    
    
    
    //cout << solver.list("Independent") << endl;
    //cout << solver.list("Dependent") << endl; quit();
    
    if(switchDes == "DESIGN"){
      
      inlet.Wengine = inlet.AoGuess(ambient.ZMN)*ambient.ZW;
      inlet.Wbleed = inlet.A0bldGuess(ambient.ZMN)*ambient.ZW; 
      inlet.Wbypass = ambient.ZW -inlet.Wengine - inlet.Wbleed ;
      inlet.eRam = inlet.eRamGuess(ambient.ZMN);
    }


  }
  void postexecute() {
    CASE++;
    
    if(PC == 50) {
      maxThrust = PERF.Fn;
    }
    if(inlet.eRam < .8) {
      cerr << "CHECK INLET RECOVERY  \n";
    }
  }  
  
  void variableChanged(string name, any oldVal) {
    if(name == "designFlag") {
      if(designFlag == TRUE) {
        setOption("switchDes","DESIGN");
      }
      if(designFlag == FALSE){
        setOption("switchDes","OFFDESIGN");
      }
    }
    else if(name == "PC") {
      if(PC == 50){
        ind_FAR.autoSetup = TRUE;
        dep_T4max.autoSetup = TRUE;
        dep_Thrust.autoSetup = FALSE;
      }
      else if(PC < 50) {
        ind_FAR.autoSetup = TRUE;
        dep_T4max.autoSetup = FALSE;
        dep_Thrust.autoSetup = TRUE;        
      }
    }
    else if(name == "switchDes") {
      if(switchDes == "DESIGN") {
        ambient.ind_W.autoSetup = TRUE;
        dep_TOCFnDes.autoSetup = TRUE;
        
        // Bypass
        ind_BPR.autoSetup = TRUE;
        dep_exRatio.autoSetup = TRUE;
        dep_fixedGeomMixer.autoSetup = FALSE;
        
        // Fuel and Speed
        ind_FAR.autoSetup = TRUE;
        dep_T4max.autoSetup = TRUE;
        dep_Thrust.autoSetup = FALSE;
        
        // Surge Margin
        fan.Rline.autoSetup = TRUE;
        fan.stallMargin.autoSetup = TRUE;
        HPC.Rline.autoSetup = TRUE;
        HPC.stallMargin.autoSetup = TRUE;
        
        // Cooling 
        bld3.HPTStage1Vane.ind_flow.autoSetup = TRUE;
        HPT.Stage1Vane.dep_flow.autoSetup=TRUE;
        bld3.HPTStage1Rotor.ind_flow.autoSetup = TRUE;
        HPT.Stage1Rotor.dep_flow.autoSetup=TRUE;
        bld3.HPTStage2Vane.ind_flow.autoSetup = TRUE;
        HPT.Stage2Vane.dep_flow.autoSetup=TRUE;
        bld3.HPTStage2Rotor.ind_flow.autoSetup = TRUE;
        HPT.Stage2Rotor.dep_flow.autoSetup=TRUE;   
        
        HPC.LPTStage1Vane.ind_flow.autoSetup = TRUE;
        LPT.Stage1Vane.dep_flow.autoSetup=TRUE;
        HPC.LPTStage1Rotor.ind_flow.autoSetup = TRUE;
        LPT.Stage1Rotor.dep_flow.autoSetup=TRUE;
      }
    
      else if(switchDes == "OFFDESIGN") {
        ambient.ind_W.autoSetup = TRUE; // Used to control fan SMN
        dep_TOCFnDes.autoSetup = FALSE;
        
        // Bypass
        ind_BPR.autoSetup = TRUE;
        dep_exRatio.autoSetup = FALSE;
        dep_fixedGeomMixer.autoSetup = TRUE;
        
        // Fuel and Speed
        ind_FAR.autoSetup = TRUE;
        dep_T4max.autoSetup = FALSE;
        dep_Thrust.autoSetup = TRUE;
        
        // Surge Margin
        fan.Rline.autoSetup = FALSE;
        fan.stallMargin.autoSetup = TRUE;
        HPC.Rline.autoSetup = FALSE;
        HPC.stallMargin.autoSetup = FALSE;
        
        // Cooling 
        bld3.HPTStage1Vane.ind_flow.autoSetup = FALSE;
        HPT.Stage1Vane.dep_flow.autoSetup=FALSE;
        bld3.HPTStage1Rotor.ind_flow.autoSetup = FALSE;
        HPT.Stage1Rotor.dep_flow.autoSetup=FALSE;
        bld3.HPTStage2Vane.ind_flow.autoSetup = FALSE;
        HPT.Stage2Vane.dep_flow.autoSetup=FALSE;
        bld3.HPTStage2Rotor.ind_flow.autoSetup = FALSE;
        HPT.Stage2Rotor.dep_flow.autoSetup=FALSE;   
        
        HPC.LPTStage1Vane.ind_flow.autoSetup = FALSE;
        LPT.Stage1Vane.dep_flow.autoSetup=FALSE;
        HPC.LPTStage1Rotor.ind_flow.autoSetup = FALSE;
        LPT.Stage1Rotor.dep_flow.autoSetup=FALSE;      
      }
    }

  }
  
  real coolingFlow(real flowTemp,real coolTemp,real metalTemp, real gasPathFlow) {
    real xFactor = 1.5;
    real safetyMargin = 150; // degrees R
    real rLeak = 4.0/3.0;
    real adjustedFlowTemp = .92*flowTemp+safetyMargin;
    real phi = (adjustedFlowTemp - metalTemp)/abs(adjustedFlowTemp - coolTemp);
    if (phi < 0) { phi = 0;}
    real vaneFlow = .022*((phi/(1-phi))**1.25)*xFactor*gasPathFlow*rLeak;
 
    return vaneFlow;
  }  
    
  // Model Elements
  Ambient ambient {
    Zalt = 53700;
    ZdTs = 0;
    ZMN = 1.8;
 
    ZW = 200;
    
    //used for off design flight
    Independent ind_W {
      varName = "ZW";
      autoSetup = FALSE;
    }
    
  }
  
  InstalledInlet inlet {
    
    #include<M2SBJInlet.map>
    S_install.Acapture  = 1280;
    Table Tb_localMN(real Mach_free) {
      Mach_free={0.0000,0.6000,2.0000}
      Mach_local={0.0000,0.6000,2.0000}
    }
    Table eRamGuess(real Mach_local) {
      Mach_local={0.0003,0.2566,0.4305,0.5680,0.6951,0.9488,1.0000,1.1000,1.1817,1.2000,
      1.3000,1.4000,1.4746,1.5000,1.6000,1.7000,1.7112,1.8000,1.9000,1.9913,2.0000}
      Rec_match={0.9502,0.9591,0.9637,0.9654,0.9660,0.9658,0.9653,0.9645,0.9637,0.9633,
      0.9620,0.9600,0.9583,0.9575,0.9548,0.9517,0.9510,0.9475,0.9420,0.9360,0.9350}
    }   
    Table AoGuess(real Mach_local) {
      Mach_local={0.4477,0.5319,0.6523,0.7361,0.7909,0.8964,1.0000,1.0180,1.1000,1.2000,
      1.2124,1.3000,1.4000,1.5000,1.5834,1.6000,1.7000,1.8000,1.9000,1.9822,2.0000}
      AoAc_match={1.0008,0.8835,0.7763,0.7340,0.7173,0.6991,0.6960,0.6961,0.7050,0.7200,
      0.7208,0.7380,0.7600,0.7792,0.8000,0.8060,0.8356,0.8654,0.9022,0.9340,0.9395}
    } 
    Table A0bldGuess(real Mach_local) {
      Mach_local={0.8162,0.9882,1.0000,1.1000,1.1286,1.2000,1.2431,1.3000,1.3575,1.4000,
      1.4875,1.5000,1.6000,1.6072,1.7000,1.7322,1.8000,1.8571,1.9000,1.9976,2.0000}
      AobldAc_match={0.0000,0.0075,0.0080,0.0120,0.0135,0.0165,0.0182,0.0208,0.0228,0.0246,
      0.0283,0.0288,0.0330,0.0332,0.0374,0.0389,0.0416,0.0441,0.0458,0.0501,0.0505}  
    }    
    
    void preexecute() {
      if(switchDes == "DESIGN" && S_install.Acapture != ambient.Fl_O.Aphy*1.1){
        S_install.Acapture = ambient.Fl_O.Aphy*1.09;
      }
    }

  }
  
  FlowEnd inletBldSink;
  FlowEnd inletBypSink;
  
  Compressor fan {
    #include<D60fan.ncp>
    Fl_O.MN = 0.30;
    
    S_map.NcDes = .95;
    S_map.PRdes = 3.0;
    S_map.effDes = 0.86;
    S_map.RlineMap = 2;
    
    real SMNDes = 20;
    Independent Rline {
      varName = "S_map.RlineMap";
    }
    Dependent stallMargin {
      eq_lhs = "SMN";
      eq_rhs = "SMNDes";
    }    
  }  
  
  Splitter2 split {
    BPR = 3.3;
    dPqP1 = 0.0;
    dPqP2 = 0.0;
    Fl_02.MN = .5;
    Fl_01.MN = .5;
  }
  
  Duct bypassDuct {
    dPqPbase = .02;
   
  }
  
  Compressor HPC {
    #include<D60hpc.ncp>
    Fl_O.MN = 0.30;
    
    S_map.RlineMap = 2;
    S_map.alphaMap = 0;
    S_map.NcDes = 90;
    S_map.PRdes = 8;
    S_map.effDes = 0.8565;    
    real tempRatio;
    
    real SMNDes = 20;
    Independent Rline {
      varName = "S_map.RlineMap";
    }
    Dependent stallMargin {
      eq_lhs = "SMN";
      eq_rhs = "SMNDes";
    }      
    
    
    InterStageBleedOutPort LPTStage1Vane {
      fracBldW = .0032;
      fracBldWork = .5;
      fracBldP = ((fracBldWork*(tempRatio-1)+1)**(S_map.gamtMap/(S_map.gamtMap-1)-1))/(S_map.PRdes-1);
      
      Independent ind_flow {
        varName = "fracBldW";
      }      
    }    
    InterStageBleedOutPort LPTStage1Rotor {
      fracBldW = .0032;
      fracBldWork = .5;
      fracBldP = ((fracBldWork*(tempRatio-1)+1)**(S_map.gamtMap/(S_map.gamtMap-1)-1))/(S_map.PRdes-1);
      
      Independent ind_flow {
        varName = "fracBldW";
      }      
    }        
    
    
    void postexecute() {
      // used in interstage bleed calculation
      tempRatio = (S_map.PRdes)**(S_map.gamtMap/(S_map.gamtMap-1));
    }
    
  }
  
  Bleed bld3{
    Fl_O.MN = 0.30;
    
    BleedOutPort HPTStage1Vane {
      fracW = .04;
      Independent ind_flow {
        varName = "fracW";
      }
    }

    BleedOutPort HPTStage1Rotor {
      fracW = .15;
      Independent ind_flow {
        varName = "fracW";
      }
    }
    
    BleedOutPort HPTStage2Vane {
      fracW = .05;
      Independent ind_flow {
        varName = "fracW";
      }
    }
    BleedOutPort HPTStage2Rotor {
      fracW = .08;
      Independent ind_flow {
        varName = "fracW";
      }
    }     
  }
  
  FuelStart Fuel36;
  Burner burner {
    Fl_O.MN = .3;
    switchBurn = "FAR";
    FAR = .03;
  }
  
  Turbine HPT {
    #include<D60hpt.ncp>
    S_map.effDes = 0.90;
    S_map.parmMap = 2.425;
    S_map.parmGeomDes  = 76;
    S_map.parmMapDes = 4.800;
    S_map.parmNcDes = 100; 

    Sh_O.inertia = 100;
    Fl_O.MN = .5;
    
    // Used for Cooling Calculations
    FlowStation Fl_interStage;
    int nStages = 2.0;
    int stage;
    real Pt_interStage;
    real deltaH;
    
    InterStageBleedInPort Stage1Vane{
      real coolingFlowReq;
      Pfract  = 1.0;
      Dependent dep_flow {
        eq_lhs = "coolingFlowReq";
        eq_rhs = "W";
      }
    }
    InterStageBleedInPort Stage1Rotor{
      real coolingFlowReq;
      Pfract  = 1.0;
      Dependent dep_flow {
        eq_lhs = "coolingFlowReq";
        eq_rhs = "W";
      }
    }
    InterStageBleedInPort Stage2Vane{
      real coolingFlowReq;
      Pfract  = .5;
      Dependent dep_flow {
        eq_lhs = "coolingFlowReq";
        eq_rhs = "W";
      }
    }
    InterStageBleedInPort Stage2Rotor{
      real coolingFlowReq;
      Pfract  = .5;
      Dependent dep_flow {
        eq_lhs = "coolingFlowReq";
        eq_rhs = "W";
      }
    }        
    
    //coolingFlow(flowTemp,coolTemp,metalTemp,gasPathFlow)
    void postexecute() {
      real tMetalRotor = 2260;
      real tMetalStator = 2360;
      deltaH = Fl_I.ht - Fl_O.ht;
      stage = 1;
      //Pt_interStage = (Fl_O.Pt + (Fl_I.Pt - Fl_O.Pt)*stage/nStages)

      //cout << Fl_I.Tt << endl;
      Stage1Vane.coolingFlowReq = coolingFlow(Fl_I.Tt,Stage1Vane.Tt,tMetalStator,Fl_I.W);
      Stage1Rotor.coolingFlowReq = coolingFlow(Fl_I.Tt,Stage1Rotor.Tt,tMetalRotor,Fl_I.W);
      
      // Take out the work from the first stage
      Pt_interStage = (Fl_O.Pt + (Fl_I.Pt - Fl_O.Pt)*stage/nStages);
      Fl_interStage.setTotal_hP(Fl_I.ht-deltaH*stage/nStages,Pt_interStage);
      
      //cout << Fl_interStage.Tt << endl<< endl;
      stage = 2;
      Stage2Vane.coolingFlowReq = coolingFlow(Fl_interStage.Tt,Stage2Vane.Tt,tMetalStator,Fl_I.W);
      Stage2Rotor.coolingFlowReq = coolingFlow(Fl_interStage.Tt,Stage2Rotor.Tt,tMetalRotor,Fl_I.W);
    }
  }
  
  Turbine LPT {
    #include<D60lpt.ncp>
    S_map.effDes = 0.94;
    S_map.parmMap = 3.56;
    S_map.parmGeomDes  = 74;
    S_map.parmMapDes = 2.7;
    S_map.parmNcDes = 100;
    
    Sh_O.inertia = 100;

    // Used for Cooling Calculations
    FlowStation Fl_interStage;
    int nStages = 2.0;
    int stage;
    real Pt_interStage;
    real deltaH;
    
    InterStageBleedInPort Stage1Vane{
      real coolingFlowReq;
      Pfract  = 1.0;
      
      Dependent dep_flow {
        eq_lhs = "coolingFlowReq";
        eq_rhs = "W";
      }
    }
    InterStageBleedInPort Stage1Rotor{
      real coolingFlowReq;
      Pfract  = 1.0;
      
      Dependent dep_flow {
        eq_lhs = "coolingFlowReq";
        eq_rhs = "W";
      }
    }
    
    
    //coolingFlow(flowTemp,coolTemp,metalTemp,gasPathFlow)
    void postexecute() {
      real tMetalRotor = 2260;
      real tMetalStator = 2360;
      deltaH = Fl_I.ht - Fl_O.ht;
      stage = 1;
      Stage1Vane.coolingFlowReq = coolingFlow(Fl_I.Tt,Stage1Vane.Tt,tMetalStator,Fl_I.W);
      Stage1Rotor.coolingFlowReq = coolingFlow(Fl_I.Tt,Stage1Rotor.Tt,tMetalRotor,Fl_I.W);
    }    
    
    

  }
  
  ConstantAreaMixer mixer {
    Fl_I1.MN = .22;
    
    real desArea; 
    
    void postexecute() {
      if(switchDes == "DESIGN") {
        desArea = Fl_I1.Aphy;
      }
    }
  }
  
  OverUnderNozzle nozzle {
    switchType = "CON_DIV";
    PsExhName = "ambient.Ps";

    switchCoef = "CFG";
    Cfg = 0.9077;    
    CdTh = .97;
    
    real Aideal;
    
   Table bowTailCd(real Mach_local, real A10A9) {
      A10A9=1.1110 {
        Mach_local={0.0000,0.8000,0.9500,1.0000,1.0400,1.2000,1.5000,2.0000,3.0000}
        Cd_aftbody={0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000}
      }
      A10A9=1.5380 {
        Mach_local={0.0000,0.8000,0.9500,1.0000,1.0400,1.2000,1.5000,2.0000,3.0000}
        Cd_aftbody={0.0000,0.0160,0.0200,0.0210,0.0200,0.0150,0.0120,0.0090,0.0060}
      }
      A10A9=2.5000 {
        Mach_local={0.0000,0.8000,0.9500,1.0000,1.0400,1.2000,1.5000,2.0000,3.0000}
        Cd_aftbody={0.0000,0.0260,0.0370,0.0550,0.0720,0.0610,0.0460,0.0330,0.0230}
      }
      A10A9=6.6670 {
        Mach_local={0.0000,0.8000,0.9500,1.0000,1.0400,1.2000,1.5000,2.0000,3.0000}
        Cd_aftbody={0.0000,0.0330,0.0550,0.1400,0.1670,0.1440,0.1110,0.0800,0.0530}
      }
      A10A9=10.000 {
        Mach_local={0.0000,0.8000,0.9500,1.0000,1.0400,1.2000,1.5000,2.0000,3.0000}
        Cd_aftbody={0.0000,0.0370,0.0660,0.1560,0.1950,0.1670,0.1260,0.0900,0.0570}
      }
    }    
    real bowTailDrag = 0;
    void postexecute() {
      bowTailDrag = bowTailCd(ambient.ZMN,inlet.S_install.Acapture*1.25/Fl_O.Aphy)* inlet.S_install.Acapture*1.25*inlet.S_install.Q;
    }
    
  }
  
  FlowEnd nozzleSink;

  newShaft HPShaft {
    //  Mechanical Ports.  These are created as needed on the shaft.
    ShaftInputPort HPC_in, HPT_in;

    HPX = 0;
    Nmech = 30346;
  }
  
  newShaft LPShaft {
    //  Mechanical Ports.  These are created as needed on the shaft.
    ShaftInputPort LPT_in, fan_in;
       
    HPX = 0;
    Nmech = 30346;
  }
  
  
  EngPerf_Assembly PERF {
    real extractionRatio; 
    real Fn_sp;
    
    void postexecute() {
      extractionRatio = mixer.Fl_I2.Pt/mixer.Fl_I1.Pt;
      
      Fg = nozzle.Fg;
      Fram = inlet.Fram + nozzle.bowTailDrag + inlet.Dinstall;
      Fn = Fg - Fram;
      Fn_sp = Fn/HPC.Fl_I.W;
      WfuelHour = Wfuel * 3600.0;
      TSFC = WfuelHour/Fn;
    }
  }
  
  // Model Links
  linkPorts("ambient.Fl_O","inlet.Fl_I","fs0");
  linkPorts("inlet.Fl_O","fan.Fl_I","fs1");
  linkPorts("inlet.BleedOut","inletBldSink.Fl_I","fs111");
  linkPorts("inlet.BypassOut","inletBypSink.Fl_I","fs112");
  linkPorts("fan.Fl_O","split.Fl_I","fs11");
    //Bypass Flow
    linkPorts("split.Fl_02","bypassDuct.Fl_I","fs13");
    linkPorts("bypassDuct.Fl_O","mixer.Fl_I2","fs17");
    // Core Flow
    linkPorts("split.Fl_01","HPC.Fl_I","fs2");
    linkPorts("HPC.Fl_O","bld3.Fl_I","fs3");
    linkPorts("bld3.Fl_O","burner.Fl_I","fs31");
    linkPorts("burner.Fl_O","HPT.Fl_I","fs4");
    linkPorts("HPT.Fl_O","LPT.Fl_I","fs42");
    linkPorts("LPT.Fl_O","mixer.Fl_I1","fs5");
  linkPorts("mixer.Fl_O","nozzle.Fl_I","fs57");
  linkPorts("nozzle.Fl_O","nozzleSink.Fl_I","fs9");
  
  //Fuel Links
  linkPorts("Fuel36.Fu_O","burner.Fu_I","fu_1");
  
  // Shaft Links
  linkPorts("fan.Sh_O","LPShaft.fan_in","sh1");
  linkPorts("LPT.Sh_O","LPShaft.LPT_in","sh2");
  linkPorts("HPC.Sh_O","HPShaft.HPC_in","sh3");
  linkPorts("HPT.Sh_O","HPShaft.HPT_in","sh4");
  
  // Bleed Links
  linkPorts("bld3.HPTStage1Vane","HPT.Stage1Vane","bld_1");
  linkPorts("bld3.HPTStage1Rotor","HPT.Stage1Rotor","bld_2");
  linkPorts("bld3.HPTStage2Vane","HPT.Stage2Vane","bld_3");
  linkPorts("bld3.HPTStage2Rotor","HPT.Stage2Rotor","bld_4");
  
  linkPorts("HPC.LPTStage1Vane","LPT.Stage1Vane","bld_5");
  linkPorts("HPC.LPTStage1Rotor","LPT.Stage1Rotor","bld_6");
 
  
  // input promotion : 
  FunctVariable alt {
    setFunction = "alt_fvSet";
    getFunction = "alt_fvGet";
  }
  void alt_fvSet(real newalt) {ambient.Zalt = newalt;}
  real alt_fvGet() {return ambient.Zalt;}
  
  FunctVariable MN {
    setFunction = "MN_fvSet";
    getFunction = "MN_fvGet";
  }
  void MN_fvSet(real newMN) {ambient.ZMN = newMN;}
  real MN_fvGet() {return ambient.ZMN;}
  
  FunctVariable Knoz {
    setFunction = "Knoz_fvSet";
    getFunction = "Knoz_fvGet";
  }
  void Knoz_fvSet(real newKnoz) {nozzle.underExp = newKnoz;}
  real Knoz_fvGet() {return nozzle.underExp;}
  
  FunctVariable FanPRdes {
    setFunction = "FanPRdes_fvSet";
    getFunction = "FanPRdes_fvGet";
  }
  void FanPRdes_fvSet(real newFanPRdes) {fan.S_map.PRdes = newFanPRdes;}
  real FanPRdes_fvGet() {return fan.S_map.PRdes;}
  
  FunctVariable HpcPRdes {
    setFunction = "HpcPRdes_fvSet";
    getFunction = "HpcPRdes_fvGet";
  }
  void HpcPRdes_fvSet(real newHpcPRdes) {HPC.S_map.PRdes = newHpcPRdes;}
  real HpcPRdes_fvGet() {return HPC.S_map.PRdes;}
  
  // outputs promotion:
  FunctVariable Fg{
    setFunction = "Fg_fvSet";
    getFunction = "Fg_fvGet";
  }
  void Fg_fvSet(any newVal) {};
  real Fg_fvGet() {return PERF.Fg;}
  
  FunctVariable Fram{
    setFunction = "Fram_fvSet";
    getFunction = "Fram_fvGet";
  }
  void Fram_fvSet(any newVal) {};
  real Fram_fvGet() {return PERF.Fram;}
  
  FunctVariable Wfuel{
    setFunction = "Wfuel_fvSet";
    getFunction = "Wfuel_fvGet";
  }
  void Wfuel_fvSet(any newVal) {};
  real Wfuel_fvGet() {return PERF.WfuelHour;}
  
  FunctVariable TSFC{
    setFunction = "TSFC_fvSet";
    getFunction = "TSFC_fvGet";
  }
  void TSFC_fvSet(any newVal) {};
  real TSFC_fvGet() {return PERF.TSFC;}   
  
  FunctVariable Fn{
    setFunction = "Fn_fvSet";
    getFunction = "Fn_fvGet";
  }
  void Fn_fvSet(any newVal) {};
  real Fn_fvGet() {return PERF.Fn;}
  
  FunctVariable nozzleExitTs{
    setFunction = "nozzleExitTs_fvSet";
    getFunction = "nozzleExitTs_fvGet";
  }
  void nozzleExitTs_fvSet(any newVal) {};
  real nozzleExitTs_fvGet() {return nozzle.Fl_O.Ts;}
  
  FunctVariable nozzleExitPs{
    setFunction = "nozzleExitPs_fvSet";
    getFunction = "nozzleExitPs_fvGet";
  }
  void nozzleExitPs_fvSet(any newVal) {};
  real nozzleExitPs_fvGet() {return nozzle.Fl_O.Ps;}   
}


import os
import sys
import pprint
import StringIO
from ConfigParser import SafeConfigParser
from optparse import OptionParser

from openmdao.util.fileutil import build_directory
from sphinx.setup_command import BuildDoc

templates = {}

# this is the template for the file that Sphinx uses to configure itself
templates['conf.py'] = """

# -*- coding: utf-8 -*-
#
# This file is execfile()d with the current directory set to its containing dir.
#
# The contents of this file are pickled, so don't put values in the namespace
# that aren't pickleable (module imports are okay, they're removed automatically).
#

import sys, os

# General configuration
# ---------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 
              'sphinx.ext.doctest', 'sphinx.ext.todo', 
              'sphinx.ext.viewcode','openmdao.util.doctools'
      ]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'%(name)s'
copyright = u'%(copyright)s'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '%(version)s'
#The short version is the one that shows up in the file when you use /version/.
# The full version, including alpha/beta/rc tags.
release = '%(release)s'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%%B %%d, %%Y'

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# Options for HTML output
# -----------------------

# The style sheet to use for HTML and HTML Help pages. A file of that name
# must exist either in Sphinx' static/ path, or in one of the custom paths
# given in html_static_path.
html_style = 'default.css'

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%%b %%d, %%Y'

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, the reST sources are included in the HTML build as _sources/<name>.
#html_copy_source = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

html_theme = "default"

# using these theme options will make the docs share a consistent
# look with the OpenMDAO docs
html_theme_options = {
     "headtextcolor": "darkred",
     "headbgcolor": "gainsboro",
     "headfont": "Arial",
     "relbarbgcolor": "black",
     "relbartextcolor": "white",
     "relbarlinkcolor": "white",
     "sidebarbgcolor": "gainsboro",
     "sidebartextcolor": "darkred",
     "sidebarlinkcolor": "black",
     "footerbgcolor": "gainsboro",
     "footertextcolor": "darkred",
     "textcolor": "black",
     "codebgcolor": "#FFFFCC",
     "linkcolor": "darkred",
     "codebgcolor": "#ffffcc",
    }

todo_include_todos = True

# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/dev': None}

autodoc_member_order = 'groupwise'

"""

templates['index.rst'] = """

%(title_marker)s
%(name)s Documentation
%(title_marker)s

Contents:

.. toctree::
   :maxdepth: 2
    
   pkgdocs
   usage
   srcdocs

  
"""


templates['srcdocs.rst'] = """

.. _%(name)s_src_label:


====================
Source Documentation
====================

.. automodule:: %(srcmod)s
   :members:
   :undoc-members:
   :show-inheritance:

"""


templates['usage.rst'] = """

===========
Usage Guide
===========

No usage information has been provided for this plugin. Consult the
:ref:`%(name)s_src_label` section for more detail.

"""


templates['setup.py'] = """

#
# This file is autogenerated during plugin_quickstart and overwritten during
# package_plugin. DO NOT CHANGE IT if you plan to use package_plugin to update 
# the distribution.
#

import sys
import os
import warnings

name = '%(name)s'
version = '%(version)s'
release = '%(release)s'

# prepend our package to python path so autodoc will find our source code
sys.path[0:0] = [os.path.join(os.path.dirname(os.path.abspath(__file__)),'src',name)]

kwargs = %(setup_options)s

from setuptools import setup

building = set([
 'build',
 'bdist',
 'sdist',
 'bdist_egg',
 'bdist_rpm',
 'bdist_wininst',
 'build_ext',
 'build_py',
])

# ensure that docs are built during any build command (assuming sphinx is available)
if 'build_sphinx' not in sys.argv:
    for arg in sys.argv[1:]:
        if arg in building:
            try:
                from sphinx.setup_command import BuildDoc
            except ImportError:
                warnings.warn("Sphinx not found so no docs will be built", Warning)
            else:
                sys.argv = [sys.argv[0], 'build_sphinx']+sys.argv[1:]
        break

# only import BuildDoc if we're building so we can avoid a sphinx
# dependency when we don't really need it
if 'build_sphinx' in sys.argv:
    from sphinx.setup_command import BuildDoc
    kwargs['cmdclass'] = { 
         'build_sphinx': BuildDoc,
    }
    kwargs['command_options'] = {
            'build_sphinx': {
                'version': ('setup.py', version),
                'release': ('setup.py', release),
                'build_dir': ('setup.py', 'src/%(name)s/sphinx_build'),
                'all_files': ('setup.py', 'true'),
                'fresh_env': ('setup.py', 'true'),
             }
        }
    mydir = os.path.dirname(os.path.abspath(__file__))
    docbuilddir = os.path.join(mydir, 'src', '%(name)s', 'sphinx_build')
    if not os.path.isdir(docbuilddir):
        os.mkdir(docbuilddir)

setup(**kwargs)

"""

templates['MANIFEST.in'] = """

graft src/%(name)s/sphinx_build/html

"""

templates['setup.cfg'] = """

[metadata]
name = %(name)s
version = %(version)s
summary = 
description-file = usage.rst
keywords = openmdao
home-page = UNKNOWN
download-url = UNKNOWN
author = UNKNOWN
author-email = UNKNOWN
maintainer = UNKNOWN
maintainer-email = UNKNOWN
license = UNKNOWN
classifier = Intended Audience :: Science/Research
    Topic :: Scientific/Engineering

requires-dist = openmdao.main
provides-dist = 
obsoletes-dist = 
requires-python = 
    >=2.6
    <2.7
requires-externals = 
project-url = UNKNOWN

"""

code_templates = {}

code_templates['openmdao.component'] = """

from openmdao.main.api import Component
from openmdao.lib.datatypes.api import Float


class %(name)s(Component):
    # declare inputs and outputs here
    #x = Float(0.0, iotype='in')
    #y = Float(0.0, iotype='out')

    def execute(self):
        # do your calculations here
        pass
        
"""

code_templates['openmdao.driver'] = """

from openmdao.main.api import Driver
from openmdao.util.decorators import add_delegate

class %(name)s(Driver):

    def start_iteration(self):
        super(%(name)s, self).start_iteration()

    def continue_iteration(self):
        return super(%(name)s, self).continue_iteration()
    
    def pre_iteration(self):
        super(%(name)s, self).pre_iteration()
        
    def run_iteration(self):
        super(%(name)s, self).run_iteration()

    def post_iteration(self):
        super(%(name)s, self).post_iteration()

"""

def get_pkgdocs(metadata):
    lines = ['\n',
             '================\n',
             'Package Metadata\n',
             '================\n',
             '\n']

    tuplist = list(metadata.items())
    tuplist.sort()
    for key,value in tuplist:
        if key == 'name':
            continue
        if value.strip():
            if '\n' in value:
                lines.append(":%s: " % key)
                for v in [vv.strip() for vv in value.split('\n')]:
                    if v:
                        lines.append("    %s\n\n" % v)
                lines.append('\n')
            elif value != 'UNKNOWN':
                lines.append(":%s: %s\n\n" % (key, value))
        
    return ''.join(lines)


def argv_to_args(argv=None):
    """Convert command line arguments into arguments passable to a python
    callable.
    
    argv: str (optional)
        A list of argument strings.  If None (the default), then sys.argv[1:]
        will be used.
    
    Returns a tuple of the form (args, kwargs).
    """
    if argv is None:
        argv = sys.argv[1:]
        
    args = []
    kwargs = {}
    
    if len(argv) == 0:
        return (args, kwargs)

    for i,arg in enumerate(argv):
        if '=' in arg:
            break
        args.append(arg)
    else:
        return (args, kwargs)
        
    for arg in argv[i:]:
        if '=' in arg:
            lhs,rhs = arg.split('=',1)
            kwargs[lhs.strip()] = rhs.strip()
        else:
            raise RuntimeError("argv_to_args: positional arg (%s) appeared after named args" %
                               arg)
    
    return (args, kwargs)


def plugin_quickstart(argv=None):
    """A command line script (plugin_quickstart) points to this.  It generates a
    directory structure for an openmdao plugin package along with Sphinx docs.
    
    usage: plugin_quickstart <plugin_name> <version> [--dest=<dest_dir>] [--group=<plugin_group>]
    
    """
    
    if argv is None:
        argv = sys.argv[1:]
    
    parser = OptionParser()
    parser.usage = "plugin_quickstart <plugin_name> <version> [options]"
    parser.add_option("-d", "--dest", action="store", type="string", dest='dest', default='.',
                      help="destination directory (parent of the new plugin directory)")
    parser.add_option("-g", "--group", action="store", type="string", dest='group', 
                      default = 'openmdao.component',
                      help="specify plugin group (openmdao.component, openmdao.driver, openmdao.variable)")
    
    (options, args) = parser.parse_args(argv)

    if len(args) < 2 or len(args) > 3:
        parser.print_help()
        sys.exit(-1)

    name = args[0]
    version = args[1]
    
    setup_options = {
        'name': name,
        'version': version,
        'packages': [name],
        'package_data': { name: [
            'sphinx_build/html/*.*',
            'sphinx_build/html/_modules/*',
            'sphinx_build/html/_sources/*',
            'sphinx_build/html/_static/*',
            ] },
        'package_dir': {'': 'src'},
        'zip_safe': False,
        'include_package_data': True,
        'install_requires': ['openmdao.main'],
    }
    
    sio = StringIO.StringIO()
    pprint.pprint(setup_options, sio)
    
    template_options = {
        'release': version,
        'copyright': '',
        'summary': '',
        'title_marker': '='*(len(name)+len(' Documentation')),
        'setup_options': sio.getvalue()
    }
    
    
    startdir = os.getcwd()
    try:
        os.chdir(options.dest)
        cfg = SafeConfigParser()
        if os.path.exists('setup.cfg'):
            stream = open('setup.cfg', 'r')
        else:
            stream = StringIO.StringIO(templates['setup.cfg'] % { 'name':name, 'version':version})
        cfg.readfp(stream, 'setup.cfg')
        metadata = dict([item for item in cfg.items('metadata')])
        template_options.update(metadata)
        cfgcontents = StringIO.StringIO()
        cfg.write(cfgcontents)
        
        plugin_py_template = code_templates[options.group]
        pycontents = plugin_py_template % template_options
        pyfile = '%s.py' % name
        template_options['srcmod'] = name
    
        dirstruct = {
            name: {
                'setup.py': templates['setup.py'] % template_options,
                'setup.cfg': cfgcontents.getvalue(),
                'MANIFEST.in': templates['MANIFEST.in'] % template_options,
                'README.txt': 'README.txt file for %s' % name,
                'src': {
                    name: {
                        '__init__.py': '',
                        pyfile: pycontents,
                        },
                    },
                'docs': {
                    'conf.py': templates['conf.py'] % template_options,
                    'index.rst': templates['index.rst'] % template_options,
                    'srcdocs.rst': templates['srcdocs.rst'] % template_options,
                    'pkgdocs.rst': get_pkgdocs(metadata),
                    'usage.rst': templates['usage.rst'] % template_options,
                    },
            },
        }

        build_directory(dirstruct)
    
    finally:
        os.chdir(startdir)

        
def _verify_dist_dir(dpath):
    if not os.path.isdir(dpath):
        raise IOError("directory '%s' does not exist" % dpath)
    
    expected = ['src', 'docs', 'setup.py', 'setup.cfg', 'MANIFEST.in',
                os.path.join('docs','conf.py'),
                os.path.join('docs','index.rst'),
                os.path.join('docs','srcdocs.rst')]
    for f in expected:
        if not os.path.exists(os.path.join(dpath, f)):
            raise IOError("director '%s' does not contain '%s'" %
                          (dpath, f))

def package_plugin(argv=None):
    """A command line script (package_plugin) points to this.  It creates a 
    source distribution containing sphinx documentation for the specified
    distribution directory.  If no directory is specified, the current directory
    is assumed.
    
    usage: package_plugin [dist_dir_path]
    
    """
    
    if argv is None:
        argv = sys.argv[1:]
        
    if len(argv) == 0:
        destdir = os.getcwd()
    elif len(argv) == 1:
        destdir = os.path.abspath(argv[0])
    else:
        raise RuntimeError("\nusage: package_plugin <dist_dir_name>\n")

    _verify_dist_dir(destdir)

    startdir = os.getcwd()
    os.chdir(destdir)
    
    try:
        pass
    finally:
        os.chdir(startdir)
